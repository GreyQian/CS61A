# 第一章 使用函数来构造抽象

## 引言

> 所有的计算都从信息的表示开始，然后确定处理逻辑的过程，和设置抽象来处理逻辑的复杂度。计算机是强大的，也是愚蠢的。编程的核心在于人的洞察力、创造力，而非计算机的算力。

学习一门语言是从实践中试错而得到的，因此独立查询资料并解决问题是极为重要的，下面是关于再调试中的一些指导原则：

- 增量调试：每一个程序都应该是由大量可以单独测试的小型模块化的组件组成。**每当完成一个模块经行测试是极为重要的，或者说必须养成的良好习惯。（当然每当学会一个技能的时候，一个首要目标就是学会如何测试它）**
- 隔离错误：模块化的编写给我们带来的其中一个好处就是当错误发生的时候，往往是出现再某个模块中，我们尝试解决问题的时候需要先将错误追踪到最小的代码片段，然后再尝试更正错误
- 检查假设：每编写一个功能的前，我们都需要确定这个功能的逻辑作用，再调试的时候，**需要将调试的重点工作放在检验自己的假设是否成立，是否逻辑上存在漏洞**
- 与他人沟通，上网查询（但是需要自己先隔离错误并解决不了之后才使用这个方法）



## 编程要素

每一种编程语言，都应该具备如下的三点基本要素

- 原始表达式和语句：是语言的最简单的构造部分
- 复合手段：将简单表达式和语句复合成为更复杂的块的一种方式
- 抽象手段：**可以将复合元素命名并作为单元操作的手段**

编程语言中有一个关键的方面，就是它提供了使用名称来指代计算对象的方法。如果一个值（对象）被给予了一个名字，我们就说这个名称绑定到了这个值。

在python中我们有如下几种方法来绑定：

- `=`：左边为名称，右边为值。**首先会计算右侧的表达式，右侧表达式确定之后，才运行赋值操作**
- `import`：本质上是将外界定义的键值绑定，引入到当前环境，也可以说在当前环境种创建了一个新的绑定
- `def`：将创建一个帧并将其与函数名相绑定

绑定值之后，需要进一步追踪这些值，这就意味着解释器必须维护某种名称和绑定的内存，这个内存成为`enviorment`



> 嵌套表达式的计算：
>
> 1. 计算运算符operator和操作数的子表达式
> 2. 当所有操作数的数值已经明确之后，才会进行计算

## 定义函数

在python中使用`def`语句后面紧跟着`function name`和以逗号隔开的参数列表。

函数的主体部分需要使用一个空格缩进符，这就代表着只有当调用函数的时候才会让其执行函数体部分的内容。

每当函数被调用的时候，就会在当前的环境中产生一个子帧（实际上python总的只实现了一个总的帧，但是在调用函数的时候，每个新产生的帧会将当前被调用函数所在的帧视为`parent frame`，由此形成了一组调用帧的链，也就形成了环境的嵌套），这个帧首先会记录函数被绑定的参数，并且当`return`或者函数体执行完的时候，该帧消失。

**名称计算的结果为在找到该名称的当前环境中最早帧中绑定到该名称的值**

函数是一个抽象的集合体，我们通常可以借助下列三个核心属性来掌握它的抽象性

1. 函数的定义域：函数所接受参数的数量，以及每个参数可以接受的范围
2. 函数的范围：函数的值域
3. 函数的作用

> **一些代码风格编写指南：**
>
> - 函数名，参数名小写并且使用下划线分隔
> - 函数名称，参数名称应该和它的含义相符合，最好能望名知意
> - 参数名可以简单使用单个字母来代替，但是并不是很建议
> - 要善于使用抽象的力量来减少复杂度，当一个函数（类）编写完成之后，应该立即测试，通过测试之后，我们将会不在聚焦于它的实现，而仅仅关注它的作用，无论在写代码还是读代码的时候都应该这样做，以此来减少复杂度，降低困难程度



## 设计函数

首先，什么是一个好的函数？

- 每一个函数应该拥有一个特定的功能，并且它的功能可以用一句简短的名称来识别，用一句简短的话语来描述，**一个函数应该像一把结构单一却很锋利的小刀，但不应该是功能复杂的瑞士军刀**
- **不要重复自己，如果发现一段代码已经重复粘贴多次的时候，这个时候困难就已经找到了函数抽象的机会**
- **函数应该是通用化的定义，例如有了计算多次幂的函数就不用在单独实现平方根的函数，我们应该让函数更加通用。**

因此，设计一个函数可以按照下列流程来做：

1. 明确逻辑和抽象，函数的构思
2. 写函数注释，确定输入输出，以及函数的逻辑，这一步帮助自己理清逻辑，以及方便后续阅读
3. **写完注释之后，明确了函数的需求，可以先写一些函数的测试**
4. 编写完成之后，**进行测试**
5. 检查代码是否存在冗余部分，可以继续抽象独立出其他函数



一个函数的注释是很重要的，一般而言，我们可以在第一句话，描述它的作用，然后解释每个参数的含义以及最后返回值的含义，一个示例如下：

```python
def pressure(v, t, n):
        """Compute the pressure in pascals of an ideal gas.

        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law

        v -- volume of gas, in cubic meters
        t -- absolute temperature in degrees kelvin
        n -- particles of gas
        """
        k = 1.38e-23  # Boltzmann's constant
        return n * k * t / v
```



**关于函数的测试：**

函数的测试是很重要的，一般而言，对于python来说，有两种常见的测试方法：

- 文件测试
- 文档测试

当编写完函数的时候，会设置一个`_test.py`文件，在文件中编写测试函数，测试函数可以使用`assert`语句来进行编写，例如：

```python
def fib_test():
        assert fib(2) == 1, 'The 2nd Fibonacci number should be 1'
        assert fib(3) == 1, 'The 3rd Fibonacci number should be 1'
        assert fib(50) == 7778742049, 'Error at the 50th Fibonacci number'
```

文档测试，即在注释文档中提供其注释信息，例如：

```python
def sum_naturals(n):
        """Return the sum of the first n natural numbers.

        >>> sum_naturals(10)
        55
        >>> sum_naturals(100)
        5050
        """
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
```

文档注释的编写起始于`>>>`然后跟上一个空格，函数测试的内容，之后再下一行写出应该得到的结果。

单次检验文档注释比较复杂，我们可以使用`python -m doctest <python_file>`这一个语句来检测所有的测试，**没有输出说明全部通过**

## Debug

当我们遇到错误的时候，python会出现下面类似的错误信息提示：

```python
Traceback (most recent call last):
  File "<pyshell#29>", line 3 in <module>
    result = buggy(5)
  File <pyshell#29>", line 5 in buggy
    return f + x
TypeError: unsupported operand type(s) for +: 'function' and 'int'
```

这个是python错误信息的调用链，最新以此出错的部分再最底部，也就是说这条信息告诉了我们，从`result = buggy(5)`这个语句调用`buggy`函数时候，再`buggy`函数的第五行出现了问题，具体的错误类型为最下面这一行的内容

### 回溯消息

```python
File "<file name>", line <number>, in <function>
```

该行为您提供以下信息：

- 文件名：包含问题的文件的名称。
- 编号：文件中导致问题的行号
- 函数：可以在其中找到行的函数的名称。

该对中的第二行（比第一行缩进得更远）显示进行下一个函数调用的实际代码行。我们可以查看这一行的具体错误内容

需要注意的是，**回溯是以“最近一次调用”为组织方式组织的**



### 错误语句

回溯消息中的最后一行是错误语句。错误语句的格式如下：

```python
<error type>: <error message>
```

即错误的类型和错误的信息

常见的错误类型总结：

- `SyntaxError`:

  - 语法错误

  - 例如：

    ```python
     File "file name", line number
        def incorrect(f)
                        ^
    SyntaxError: invalid syntax
    ```

  - **符号 `^` 指向包含无效语法的代码**。错误消息不会告诉您出了什么问题，会告诉我们位置。

- `IndentationError`

  - 缩进错误

  - 例如：

    ```python
     File "file name", line number
        print('improper indentation')
    IndentationError: unindent does not match any outer indentation level
    ```

  - 显示出来的是缩进错误的那一行

- `TypeError`

  - 类型错误

- `NameError`

  - 名称错误
  - 一般是因为变量未分配给任何内容或不存在。

- `IndexError`

  - 索引超出边界

**常见的一些错误：**

- 拼写错误
- 缺少括号：
  - 如果现实`SyntaxError`并且指向一个看似正确的行，可能忘记了某处的括号
- `=`和`==`
- 无限循环，或者循环的次数相差1。


## 高阶函数

python给我们提供了这些手段，来丰富函数的功能，以便于更好的实现抽象：

- **函数可以作为参数，大大提高了通用性**
- **函数可以作为返回值**
- **可以再函数中嵌套定义函数，这样避免了全局框架的混乱**



> 在函数中嵌套定义函数，就需要我们拓展我们对环境的认识
>
> - 我们需要给每个函数定义一个`parent`，在哪儿定义这个函数，这个帧就是该函数的`parent`，**调用用户自定义函数的时候，创建的帧域函数拥有相同的父级**
> - **在环境中查找变量的时候，如果当前环境不存在，我们就会去父环境中寻找，一直迭代往前走，如果最后到了global都没有的时候，就会出现NameError**
>
> **这就给我们带来了一下的好处：**
>
> - 局部函数，不会污染全局帧，避免了全局帧的紊乱
> - **局部定义函数，可以访问父亲的环境，这就是后续闭包和装饰器的基础**



**科里化**

科里化是指将接受多个参数的高阶方程，转换为每个接受单个参数的函数链的一种方法。

$具体而言，就是将f(x,y)转换为g(x)(y)$的一种方式

对于某些只接受一个参数的语言来说，柯里化是很有用的。



**lambda表达式**

格式：

```python
lambda 参数:表达式
```



**装饰器**

装饰器是`python`中的一种特殊语法，它的目的是为了增强（或者修改）函数的功能。

具体而言，我们首先使用之前函数的高阶语法，定义出一个框架，然后我们可以使用`python`中`@`这一个语法糖来将我们的这个框架增强到我们新定义的函数中

```python
>>> def trace(fn):
        def wrapped(x):
            print('-> ', fn, '(', x, ')')
            return fn(x)
        return wrapped

>>> @trace
    def triple(x):
        return 3 * x

>>> triple(12)
->  <function triple at 0x102a39848> ( 12 )
36
```

在这个例子中，定义了一个高阶函数 `trace`，它返回一个函数，该函数在调用其参数前先输出一个打印语句来显示该参数。`triple` 的 `def` 语句有一个注解（annotation） `@trace`，它会影响 `def` 执行的规则。和往常一样，函数 `triple` 被创建了。但是，名称 triple 不会绑定到这个函数上。相反，这个名称会被绑定到在新定义的 `triple` 函数调用 `trace` 后返回的函数值上。

代码中，这个装饰器等价于：

```python
>>> def triple(x):
        return 3 * x
>>> triple = trace(triple)
```


