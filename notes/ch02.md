# 使用数据进行抽象

再第一章中，我们通过使用原始的数据和算术方式，通过组合和控制形成了复合函数，并且通过给他们命名来构成函数，以实现抽象。这里的抽象在于帮助我们使用名称简化操作，方便我们降低程序的复杂度。同时高阶函数的一些能力，帮我们提升语言的表现能力。

本章主要介绍的内容是，使用内置的数据类型和用户自定义的数据类型，来管理我们的数据，简化数据的复杂性，对数据经行抽象。

## 原生数据

python中每个值都对应着一个类(class)，用于确定它的类型以及能拥有什么行为，我们可以使用`type(数据)`来查看这个这个值对应的类。

python有一下几种原生的数据类型：

- `type(1)`->int
- Numbers: 包含下面三种
  - `type(1.5)`->float
  - `type(1+2j)`->complex
  - `type(True)`->Booleans
- String
- List: **列表也是原生数据类型**
- Tuple: 元组
- Sets：集合
- Dictionaries: 字典



## 数据抽象

当我们考虑世界上我们想要在程序中代表的事物时，我们发现它们中的大多数都具有复合结构。例如，地理位置具有纬度和经度坐标。为了表示位置，我们希望我们的编程语言能够将纬度和经度耦合在一起以形成一对，我们的程序可以将其作为单个概念单元进行操作。

复合数据的使用使我们能够提高程序的模块化。如果我们可以将地理位置作为整体值进行操作，那么我们就可以屏蔽使用位置进行计算的程序部分，使其免受这些位置如何表示的细节的影响。**将程序中处理数据表示方式的部分与处理数据操作方式的部分隔离开来的一般技术是一种强大的设计方法，称为数据抽象**。数据抽象使程序更易于设计、维护和修改。

数据抽象在性质上类似于函数抽象。当我们创建函数抽象时，可以抑制函数如何实现的细节，并且特定函数本身可以被具有相同整体行为的任何其他函数替换。换句话说，我们可以进行一个抽象，将函数的使用方式与函数实现方式的细节分开。类似地，数据抽象将复合数据值的使用方式与构造方式的细节隔离开来。

数据抽象的基本思想是构建程序，以便它们对抽象数据进行操作。也就是说，我们的程序应该以尽可能少地对数据做出假设的方式使用数据。同时，具体的数据表示被定义为程序的一个独立部分。



> 为了模拟我们生活中的事物，我们通常需要使用多种数据复合起来用于表示他们。但是这样会在操作数据方面给我们增添了很多复杂性。**因此，我们需要将数据的表示和处理分别使用函数抽象出来，以后在使用数据的时候，调用相应操作的函数即可，这就降低了数据操作和表示的复杂性，即数据抽象**
>
> **抽象障碍：**
>
> 所谓抽象障碍是指，我们在构造抽象的时候，上层的函数的构建，只能调用它下面那一层的函数来实现这个函数，禁止使用最底层的实现。例如：当你实现了有理数的乘法的时候，你想实现有理数的平方，就应该去调用乘法来实现，而不是从构建数据这种最基层的东西开始编写函数。
>
> 抽象障碍对减少代码的复杂性很有帮助，最重要的是它的实现更加通用，**当你修改了底层的规则的时候，如果你违反了抽象障碍，那么你的代码就可能就需要重写**，需要时刻注意遵守这个规则。



## 序列

> **序列是值的有序集合**，序列是一类数据类型的统称，他们通常具有下面几个特点：
>
> - 值是有序的
> - 序列有长度，空序列的长度为0
> - 可以使用index经行元素的选择

### 列表

一些内置的行为：

- `len(list)`：计算长度
- `list[index]`：索引
- `+`：列表之间可以相加，加法会生成一个新列表，这个列表的值是之前所有列表中值按照加的顺序串联
- `* 数字`：列表✖一个数字，返回一个新列表，这个列表的值是num个原始列表的值的串联
- `for <name> in <expression>`：可以使用for语句经行循环迭代
- `list(iterable)`：将可迭代对象转换为列表
- `in`：判断元素是否出现在序列之中
- **切片**：
  - 切片的语法：`start: end: step`
  - **如果有多维，不同维度之间使用，分隔**
  - 一切特殊情况：
    - `a[1:3]`,step=1
    - `a[1:-1]`,使用负数代表倒数第几个数字，-1代表最后一个数
    - `a[:3]`,默认开头为0和步长为1
    - `a[:]`默认为所有元素
    - `a[1:]`，默认结尾为最终的元素
- 集合：
  - 将列表中的所有值，聚合成单个值
  - `sum(list)`
  - `min(list)`
  - `max(list)`

> **解包：**
>
> 在Python中，序列解包是一种方便的方法，可以将一个序列（如列表或元组）中的元素解包到多个变量中。这使得我们可以一次性地将序列中的多个值分配给多个变量，而不必逐个索引或访问序列中的元素。
>
> 例如：
>
> ```python
> # 定义一个包含多个元素的列表
> my_list = [1, 2, 3]
> # 使用序列解包将列表中的元素赋值给多个变量
> a, b, c = my_list
> 
> # 可以使用*结合使用，用于解包不定长度的序列
> my_list = [1, 2, 3, 4, 5]
> a, b, *rest = my_list
> 
> # 可以用于循环中
> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
> for x, y in pairs:
>  if x == y:
>     same_count = same_count + 1
> 
> # 还可以将这个技巧使用在函数中
> def x(*args):
>  print(type(args))
>  print(args)
> 
> def y(*args):
>  print(f"y's {args=}")
>  a, *b = args
>  x(*b)
> ```



### 序列处理

python提供了一些内置的方法来对序列经行一些处理

**列表推导式：**

列表推导式用简洁的语法来构造一个列表，常用于列表的构造或者筛选，其基本语法如下：

```python
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

其形成的过程为，对于可以迭代对象的每个元素，我们使用for语句遍历，然后使用if来筛选元素，最后使用`map`表达式来对其经行一些操作

**使用内置函数经行迭代处理：**

如果我们想遍历可迭代序列，并且想对它们经行一些操作，处理上述使用列表推导式之外，还可以使用下面这些函数来帮忙：

`map()` 函数接受一个函数和一个可迭代对象（如列表），并将该函数应用于可迭代对象中的每个元素，返回一个`map`的可迭代对象，我们可以使用list等方式，将其转换为序列。

```python
map(function, iterable)
```

例如：

```python
# 定义一个函数，用于计算每个元素的平方
def square(x):
    return x * x

# 使用map()函数将square函数应用于列表中的每个元素
my_list = [1, 2, 3, 4, 5]
result = list(map(square, my_list))

print(result)  # 输出: [1, 4, 9, 16, 25]
```

`filter()` 函数用于过滤可迭代对象中的元素，它接受一个函数和一个可迭代对象作为参数，并返回一个由使得函数返回 `True` 的元素组成的迭代器

```python
filter(function, iterable)
```

例如：

```python
# 定义一个函数，用于过滤偶数
def is_even(x):
    return x % 2 == 0

# 使用filter()函数过滤列表中的偶数
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = list(filter(is_even, my_list))

print(result)  # 输出: [2, 4, 6, 8, 10]
```



### 字符串

字符串也是一种序列，它的具备很多和列表一样的操作，下面介绍一下字符串的内置操作：

- 字符串可以使用`''`或者`""`引用
- **in 用于检查某个字串是否在字符串中**
- `""" """`三个引号可以使得字符串不限于一行
- `str(object)`：用于构造字符串
- 字符串也可以使用`+`和`*`
- `b"string"`可以将字符串的内容转换为字节串

**格式化字符串：**

格式化字符串有下面三种方法：

- 使用`%`操作符：

  ```python
  name = "Alice"
  age = 30
  message = "My name is %s and I am %d years old." % (name, age)
  ```

- 使用`format()`方法

  ```python
  message = "My name is {} and I am {} years old.".format(name, age)
  ```

- 使用`f-string`

  ```python
  name = "Alice"
  age = 30
  message = f"My name is {name} and I am {age} years old."
  ```



**常见的内置函数：**

- `string.upper()`：转换为大写
- `string.lower()`：转换为小写
- `string.strip()`：去除字符串两端的空白符
- `string.split(substring)`：按照字串分割并且返回分割之后的字串列表
- `"间隔符".join(字符串列表)`：将字符串列表合并
- `string.replace(str1,str2)`：用str2来替换字符串中的str1
- `string.find(substring)`：查找指定子串在字符串中第一次出现的索引位置，如果不存在则返回 `-1`。
- `string.index(substring)`：查找指定子串在字符串中第一次出现的索引位置，如果不存在则会引发 ValueError 异常。
- `string.count(substring)`:  方法用于计算指定子串在字符串中出现的次数。


### 元组

元组是不可变对象，元组在文本中使用,号隔开，括号可选，也就是说

```python
1, 2 + 3
(1, 2+3)
```

都是表现同一个元组。

空元组表示为：`()`

单个元组表示为：`(1,)`注意这里不能省略`,`

元组通常在多重赋值中隐式使用。将两个值分配给两个名称会创建一个双元素元组，然后将其解压缩。

**常用操作：**

- 切片：
- 拼接：元组可以使用`+`来拼接
- 重复：元组可以使用`*`来重复元素
- **解包：** 元组可以通过赋值来解包，例如：`a, b, c = tuple_1`
- 计算某个元素出现次数：`tuple.count(num)`能计算`num`在元组中出现的次数
- 索引：`tuple.index(num)`获得num所在的索引

### 字典

字典是一种按照键值对索引的的对象，创建字典的目的在于，提供一种抽象，用于存储和检索不是连续整数而是按描述性键索引的值。

**常用操作：**

- 删除键值对：`del dict['a']`这种语法用于删除键值对
- 获取键的列表：`dict.keys()`
- 获取值的列表：`dict.values()`
- 获取键值对的列表：`dict.items()`
- **字典推导式：**`{x:x**2 for x in range(10)}`
- 清空字典：`dict.clear()`
- 复制字典：`dict.copy()`
- 合并字典：`dict.update(new_dict)`



## 隐式序列

序列可以表示，而无需将每个元素显式存储在计算机的内存中。也就是说，我们可以构造一个对象，该对象提供对某个顺序数据集的所有元素的访问，**而无需预先计算每个元素的值。相反，当有需要的时候，我们才会计算元素将其储存在内存中。**

例如`range`函数，一个`range`表示一段连续的有界整数序列，但是并非每个元素都存储在内存中，只有当从`range`中请求元素的时候，才会计算元素。这样就能极大的减少内存空间的占用。

```python
r = range(10, 100000000000000)
r[45689] # 只有在调用的时候，才会计算它的值，其他时候，range并没有把所有值存储在内存中
```



### 迭代器

python和其他语言提供了一种统一的方式来处理顺序容器的值，称之为迭代器。**迭代器时一个对象，它提供序列对象值的访问，并且是one by one，一个接一个的访问。**

**创造迭代器：**

对于序列容器，我们可以使用`iter(contianer)`来获取这个容器的迭代器。

```python
prime = [1,3,5,7]
iterator = iter(prime)
```

**迭代器的行为：**

迭代器给我们提供了两种抽象的接口：

- `next(it)`用于查看正在处理的序列中的下一个元素的机制
- 在调用`next`发生`StopIteration`用于指示序列是否达到末尾而没有其他元素保留。



任何可以生成迭代器的值都称为可迭代值。在python中，可迭代值是可以传递给内置`iter`函数的任何值。常见的可迭代对象有：

- 序列值：列表、字符串、元组
- 一些其他容器：集合、字典（迭代器创建的是关于键的迭代）
- **迭代器**：`iter(迭代器)`创建一个共享位置指标的迭代器,两个迭代器是同一个对象



> `for`语句遍历列表等序列的过程，例如：
>
> ```python
> mylist = [1, 2, 3]
> for i in mylist:
>     print(i)
> ```
>
> 实际上，是先调用`__iter__()`方法，产生一个迭代器，然后一直调用`__next__()`方法，再不发生`stoperror`的情况下，获取值，并将值绑定到名称`i`上，二者等价：
>
> ```python
> >>> items = counts.__iter__()
> >>> try:
>         while True:
>             item = items.__next__()
>             print(item)
>     except StopIteration:
>         pass
> ```

**一些应用：**

- `map(f, iterbale)`
  - 将可迭代对象中的每一个值，都应用`f`函数，**并返回一个迭代器。**从意义上来所，它其实和`[f(x) for x in iterable]`是一样的，但是，产生迭代器就意味着使用更少的内存，并且由于延迟计算，能产生无穷多个元素
- `filter(f, iterable)` ：**返回迭代器，f函数用于筛选**
- `zip(iterables*)` ：
  - 接受多个迭代对象，然后返回一个迭代器，迭代器产生的每个对象是这些可迭代对象的元素拼接起来的元组
- `reversed(iterable)` 以相反的顺序在输入可迭代中的所有元素上创建迭代器
- `sorted(iterable)` **返回一个排好序的列表**

### 生成器

生成器就是使用`yield`语句来替代`return`作为函数结束标志的一类函数。`yield` 的作用是暂停函数的执行，并返回一个值给调用者，但保留函数的状态，以便下一次调用时可以利用函数中所有的值。生成器可以通过循环或者其他逻辑控制语句来生成序列中的下一个值，而不需要事先将所有可能的值存储在内存中。

生成器的一个常见应用是处理大量数据或者无限序列，因为它们能够以惰性计算的方式逐个地产生值，而不需要一次性将所有数据加载到内存中。这在处理大型数据集或者需要逐个处理数据的情况下非常有用。

生成器同样具有`__next__()`方法，用于产生下一个值。

产生生成器的方法，通常由如下两种：

- `yield`语句
- **生成器表达式**：`gen = (x ** 2 for x in range(5))`



### 可迭代接口

**如果一个对象，在调用`__iter__()`方法的时候能够返回一个迭代器，那么我们认为这个对象是可迭代的。**因此，如果想一个对象时可迭代对象，我们通常需要重写`__iter__()`方法。

迭代器的接口，是通过使用重写`__next__`来实现的。例如：

```python
 class LetterIter:
        """An iterator over letters of the alphabet in ASCII order."""
        def __init__(self, start='a', end='e'):
            self.next_letter = start
            self.end = end
        def __next__(self):
            if self.next_letter == self.end:
                raise StopIteration
            letter = self.next_letter
            self.next_letter = chr(ord(letter)+1)
            return letter
```

在实现迭代器时，通常会同时定义 `__iter__` 和 `__next__` 方法。

- `__iter__` 方法返回一个迭代器对象，使得对象可以在迭代上下文中使用，而 `__next__` 方法定义了迭代器的行为，用于逐个返回序列中的元素。
- 通过定义这两个方法，可以使得对象支持迭代，可以使用 `for` 循环、迭代器的 `next()` 方法或者 `iter()` 函数来进行迭代操作。

```python
class MyIterator:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < self.limit:
            result = self.current
            self.current += 1
            return result
        else:
            raise StopIteration

# 使用迭代器
my_iter = MyIterator(5)
for value in my_iter:
    print(value)  # 输出：0 1 2 3 4
```






